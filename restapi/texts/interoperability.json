{
    "interoperability":"<p>The interoperability empirically analyses the SPARQL 1.0 and SPARQL 1.1 features supported by an endpoint. The goal is to see if the endpoint accepts and returns a valid response for queries using a variety of different SPARQL 1.0 and SPARQL 1.1 features. The queries we use are inspired by the official W3C test-case suites. However, in the interest of not overwhelming endpoints with very expensive queries, we have modified the original queries to be more friendly to remote endpoints by inserting URIs that should not appear in the remote data; thus the queries should not generate large (intermediate) result sets. </p><p>Refer to the Interoperability description for more information.</p>",
	
	"SPARQL 1.0":"<p>SPARQL is the W3C standard query language for RDF. It allows to retrieve and manipulate data stored using several operators like joins, unions, optional patterns or filters.</p>",
    "SPARQL 1.1":"<p>SPARQL 1.1 is the second version of the W3C standard query language for querying RDF databases. This new version adds new operators such aggregates, new functions and the possibility to federate queries to several SPARQL endpoints.</p>",
	"Solution Modifiers":"<p><b>SPARQL 1.0 with solution modifiers:</b></p><ul><li>SEL[.]*ORDERBY*OFFSET</li><li>SEL[.]*ORDERBY-ASC</li><li>SEL[.]*ORDERBY-DESC</li><li>SEL[.]*ORDERBY</li><li>SEL-DISTINCT[.]</li><li>SEL-REDUCED[.]</li></ul>",
	"Common Operators and Filters":"<p><b>SPARQL 1.0 common operators and filters:</b></p><ul><li>SEL[.]</li><li>SEL[JOIN]</li><li>SEL[OPT]</li><li>SEL[UNION]</li><li>SEL[FIL(!BOUND)]</li><li>SEL[FIL(BLANK)]</li><li>SEL[FIL(BOOL)]</li><li>SEL[FIL(IRI)]</li><li>SEL[FIL(NUM)]</li><li>SEL[FIL(REGEX)]</li><li>SEL[FIL(REGEX-i)]</li><li>SEL[FIL(STR)]</li><li>SEL[BNODE]</li><li>SEL[EMPTY]</li></ul>",
	"Graph and other":"<p><b>SPARQL 1.0 GRAPH and other query operators:</b></p><ul><li>SEL[FROM]</li><li>SEL[GRAPH]</li><li>SEL[GRAPH;JOIN]</li><li>SEL[GRAPH;UNION]</li><li>CON[.]</li><li>CON[JOIN]</li><li>CON[OPT]</li><li>ASK[.]</li></ul>",
	"Aggregate":"<p><b>SPARQL 1.1 aggregate functions:</b></p><ul><li>SEL[AVG]*GROUPBY</li><li>SEL[AVG]</li><li>SEL[COUNT]*GROUPBY</li><li>SEL[MAX]</li><li>SEL[MIN]</li><li>SEL[MINUS]</li><li>SEL[SUM]</li></ul>",
	"Filter":"<p><b>SPARQL 1.1 filter functions:</b></p><ul><li>SEL[FIL(!EXISTS)]</li><li>SEL[FIL(ABS)]</li><li>SEL[FIL(CONTAINS)]</li><li>SEL[FIL(EXISTS)]</li><li>SEL[FIL(START)]</li></ul>",
	"Other":"<p><b>Other SPARQL 1.1 features:</b></p><ul><li>ASK[FIL(!IN)]</li><li>CON-[.]</li><li>SEL[BIND]</li><li>SEL[PATHS]</li><li>SEL[SERVICE]</li><li>SEL[SUBQ]</li><li>SEL[SUBQ;GRAPH]</li><li>SEL[VALUES]</li></ul>",
  
	"ask[.]": "<p><b>SPARQL simple ASK query:</b></p><p>ASK {</p><p>?s ex:type ex:thing</p><p>} </p>",
	"con[.]": "<p><b>SPARQL CONSTRUCT query with a single-triple pattern returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x ex:type ?o }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o .</p><p>} LIMIT 10</p>",
	"con[join]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and a join returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x ex:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o .</p><p>&nbsp;&nbsp;?o ex:type ?x</p><p>} LIMIT 10</p>",
	"con[opt]": "<p><b>SPARQL CONSTRUCT query with two triple patterns and an optional returning an RDF graph of resources and their types:</b></p><p>CONSTRUCT { ?x ex:type ?v }</p><p>WHERE</p><p>{</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o .</p><p>&nbsp;&nbsp;OPTIONAL {?o ex:type ?v }</p><p>} LIMIT 10</p>",
	"sel[.]": "<p><b>SPARQL SELECT query with a single-triple pattern: </b></p><p>SELECT * WHERE { nonsensical:1 ex:type ?o }  LIMIT 10</p>",
	"sel[bnode]": "<p><b>SPARQL SELECT query with a single-triple pattern querying for a random blank node:</b></p><p>select distinct * where {?c ex:type _:bn} LIMIT 10</p>",
	"sel[empty]": "<p><b>SPARQL SELECT query with a single-triple pattern returning no results (using a non existing URI):</b></p><p>SELECT * WHERE { ?s ex:type nonsensical:1 }LIMIT 10</p>",
	"sel[fil(!bound)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT *</p><p>WHERE</p><p>{ nonsensical:1 ex:type ?c . </p><p>&nbsp;&nbsp;OPTIONAL { ?c ex:type ?e } . </p><p>&nbsp;&nbsp;FILTER (! bound(?e)) </p><p>} LIMIT 10</p>",
	"sel[fil(blank)]": "<p><b>SPARQL SELECT query with a single-triple pattern filtering only blank nodes:</b></p><p>SELECT * WHERE { nonsensical:1 ex:type ?v . FILTER isBlank(?v) . } LIMIT 10</p>",
	"sel[fil(bool)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a boolean in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o false</p><p>} LIMIT 10</p>",
	"sel[fil(iri)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering for variables being an IRI:</b></p><p>SELECT * WHERE { nonsensical:1 ex:type ?v . FILTER isIRI(?v) . } LIMIT 10</p>",
	"sel[fil(num)]": "<p><b>SPARQL SELECT query with a single-triple pattern and an integer in the object position:</b></p><p>SELECT * WHERE {</p><p>?s ?o 12</p><p>} LIMIT 10</p>",
	"sel[fil(regex)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, case sensitive:</b></p><p>SELECT *</p><p>WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\")</p><p>} LIMIT 10</p>",
	"sel[fil(regex-i)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filtering variables containing the \"thi\" string, ignoring case:</b></p><p>SELECT *</p><p>WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?val .</p><p>&nbsp;&nbsp;FILTER regex(?val, \"thi\", \"i\")</p><p>} LIMIT 10</p>",
	"sel[fil(str)]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FILTER operator filering for variables containing string values:</b></p><p>SELECT * WHERE {</p><p>&nbsp;&nbsp;  nonsensical:1 ex:type ?v .</p><p>&nbsp;&nbsp;  FILTER(datatype(xsd:string(?v)) = xsd:string) .</p><p>} LIMIT 10</p>",
	"sel[from]": "<p><b>SPARQL SELECT query with a single-triple pattern and a FROM NAMED clause:</b></p><p>SELECT * FROM &lt;http://non.default.graph.com/graph1&gt; </p><p>FROM NAMED &lt;http://non.default.graph.com/graph2&gt; { nonsensical:1 ex:type ?o } LIMIT 10</p>",
	"sel[graph;join]": "<p><b>SPARQL SELECT query with a join of two triple patterns using GRAPH in one of the triple patterns:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o .</p><p>&nbsp;&nbsp;  GRAPH ?g { ?o ex:type ?q }</p><p>} LIMIT 10</p>",
	"sel[graph;union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using GRAPH in one of the union sides:</b></p><p>SELECT * </p><p>{ </p><p>&nbsp;&nbsp; { ?s ?p ?o }</p><p>&nbsp;&nbsp;UNION</p><p>&nbsp;&nbsp; { GRAPH ?g { ?s ?p ?o } }</p><p>} LIMIT 10</p>",
  "sel[graph]": "<p><b>SPARQL SELECT query with a GRAPH operator and a single triple pattern:</b></p><p>SELECT * { </p><p>&nbsp;&nbsp;  GRAPH ?g { nonsensical:1 ex:type ?o }</p><p>} LIMIT 10</p>",
	"sel[join]": "<p><b>SPARQL SELECT query with two triple patterns and a join:</b> SELECT * WHERE { nonsensical:1 ex:type ?o . ?o ?p ex:thing } LIMIT 10</p>",
	"sel[opt]": "<p><b>SPARQL SELECT query with two triple patterns and an optional:</b> SELECT * WHERE { nonsensical:1 ex:type ?o OPTIONAL {?o ?p ?x}} LIMIT 10</p>",
	"sel[union]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns:</b> SELECT * WHERE { {?s ex:type ex:thing} UNION {?s ex:type ex:string}} LIMIT 10</p>",
	"sel-distinct[.]": "<p><b>SPARQL SELECT query with a single-triple pattern using DISTINCT:</b> SELECT DISTINCT * WHERE { nonsensical:1 ex:type ?o } LIMIT 10</p>",
	"sel-reduced[.]": "<p><b>SPARQL SELECT query with a UNION of two triple patterns using REDUCED:</b></p><p>SELECT REDUCED * </p><p>WHERE { </p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o</p><p>} LIMIT 10</p>",
  
	"ask[fil(!in)]": "<p><b>SPARQL 1.1 ASK query filtering using the NOT IN operator:</b></p><p>ASK {</p><p>&nbsp;&nbsp;FILTER(2 NOT IN ())</p><p>}</p>",
  "con-[.]": "<p><b>SPARQL 1.1 using the short CONSTRUCT form:</b></p><p>CONSTRUCT WHERE { nonsensical:1 ?p ?o} LIMIT 10</p>",
  "sel[avg]": "<p><b>SPARQL 1.1 SELECT query selecting using the average aggregate function:</b></p><p>SELECT (AVG(?o) AS ?avg)</p><p>WHERE{</p><p>&nbsp;&nbsp;nonsensical:1 ?p ?o</p><p>} LIMIT 10</p>",
	"sel[bind]": "<p><b>SPARQL 1.1 SELECT query using the BIND operator:</b></p><p>SELECT ?z</p><p>{</p><p>&nbsp;&nbsp;nonsensical:1 ?p ?o .</p><p>&nbsp;&nbsp;BIND(?o+10 AS ?z)</p><p>} LIMIT 10</p>",
	"sel[fil(!exists)]": "<p><b>SPARQL 1.1 SELECT query filtering for non existing triple patterns (FILTER NOT EXISTS operator):</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?s ex:type ex:thing .</p><p>&nbsp;&nbsp;FILTER NOT EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?s ex:sameAs nonsensical:1</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 10</p>",
  "sel[fil(abs)]": "<p><b>SPARQL 1.1 SELECT query filtering for the absolute value of an integer:</b></p><p>SELECT * WHERE {</p><p>&nbsp;&nbsp;?num ex:type xsd:integer</p><p>&nbsp;&nbsp;FILTER(ABS(?num) >= 2)</p><p>} LIMIT 10</p>",
	"sel[fil(contains)]": "<p><b>SPARQL 1.1 SELECT query using filtering results using the string CONTAINS operator:</b></p><p>SELECT * WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?str</p><p>&nbsp;&nbsp;FILTER CONTAINS(?str, \"a\")</p><p>} LIMIT 10</p>",
	"sel[fil(exists)]": "<p><b>SPARQL 1.1 SELECT query filtering for existing triple patterns (FILTER EXISTS operator):</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;?s ex:type ex:thing .</p><p>&nbsp;&nbsp;FILTER EXISTS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?s ex:sameAs nonsensical:1</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 10</p>",
	"sel[fil(start)]": "<p><b>SPARQL 1.1 SELECT query filtering for the STRSTARTS string function:</b></p><p>SELECT ?s ?str WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?str</p><p>&nbsp;&nbsp;FILTER STRSTARTS(STR(?str), \"h\")</p><p>}</p>",
	"sel[max]": "<p><b>SPARQL 1.1 SELECT query using the MAX average function:</b></p><p>SELECT (MAX(?o) AS ?max)</p><p>WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o</p><p>} LIMIT 10</p>",
	"sel[min]": "<p><b>SPARQL 1.1 SELECT query using the MIN average function:</b></p><p>SELECT (MIN(?o) AS ?min)</p><p>WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o</p><p>} LIMIT 10</p>",
	"sel[minus]": "<p><b>SPARQL 1.1 SELECT query using the MINUS operator:</b></p><p>SELECT *</p><p>WHERE</p><p>{&nbsp;&nbsp;nonsensical:1 ex:type ?type .</p><p>&nbsp;&nbsp;MINUS {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;?type ex:sameAs ?same</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 10</p>",
	"sel[paths]": "<p><b>SPARQL 1.1 SELECT query containing a Property Path expression:</b></p><p>select * where {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type* ?z</p><p>}  LIMIT 10</p>",
  "sel[service]": "<p><b>SPARQL 1.1 SELECT query containing a SERVICE call to DBpedia:</b></p><p>SELECT ?o </p><p>{</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o .</p>  <p>&nbsp;&nbsp;SERVICE &lt;http://dbpedia.org/sparql&gt; {</p><p>&nbsp;&nbsp;&nbsp;&nbsp;nonsensical:2 ex:type ?o</p><p>&nbsp;&nbsp;}</p><p>} LIMIT 10</p>",
  "sel[subq;graph]": "<p><b>SPARQL 1.1 SELECT query using with a subquery and a GRAPH operator:</b></p><p>select  ?y where {</p><p>graph ?g {</p><p>{select * where {nonsensical:1 ex:type ?y}}</p><p>}</p><p>} LIMIT 10</p>",
  "sel[subq]": "<p><b>SPARQL 1.1 SELECT query with a sub select in it:</b></p><p>select ?y</p><p>where {</p><p>&nbsp;&nbsp;{select * where {nonsensical:1 ex:type ?y}}</p><p>} LIMIT 10</p>",
	"sel[sum]": "<p><b>SPARQL 1.1 SELECT query using the SUM average function:</b></p><p>SELECT (SUM(?o) AS ?sum)</p><p>WHERE {</p><p>&nbsp;&nbsp;nonsensical:1 ex:type ?o</p><p>} LIMIT 10</p>",
	"sel[values]": "<p><b>SPARQL 1.1 SELECT query using the VALUES operator for restricting queries:</b></p><p>SELECT ?o</p><p>{nonsensical:1 ?p ?o} </p><p>VALUES ?o { ex:thing }</p>",	
  
  "sel[.]*orderby*offset": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable using LIMIT and OFFSET typically used for paginating results:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p><p>OFFSET 101</p>",
	"sel[.]*orderby-asc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in an ascending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
	"sel[.]*orderby-desc": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the subject variable in a descending way:</b></p><p>SELECT *</p><p>WHERE { ?s rdf:type ?o}</p><p>ORDER BY DESC(?s) LIMIT 100</p>",
	"sel[.]*orderby": "<p><b>SPARQL SELECT query with a single-triple pattern ordering results by the object variable:</b></p><p>SELECT ?v</p><p>WHERE { ?s rdf:type ?v }</p><p>ORDER BY ?v</p><p>LIMIT 100</p>",
  "sel[avg]*groupby": "<p><b>SPARQL 1.1 SELECT query using the average aggregate function in the SELECT clause, grouping the results:</b></p><p>PREFIX : &lt;http://www.example.org/&gt;</p><p>PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;</p><p>SELECT ?s (AVG(?o) AS ?avg)</p><p>WHERE {</p><p>&nbsp;&nbsp;?s rdf:type ?o</p><p>} </p><p>GROUP BY ?s</p><p>HAVING (AVG(?o) <= 2.0)</p><p>LIMIT 100</p>",
  "sel[count]*groupby": "<p><b>SPARQL 1.1 SELECT query selecting using the count aggregate function and grouping the results:</b></p><p>SELECT ?P (COUNT(?O) AS ?C)</p><p>WHERE { ?S ?P ?O } </p><p>GROUP BY ?P</p><p>LIMIT 100</p>"
}